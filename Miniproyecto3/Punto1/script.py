"""This code solves the Poisson equation in 1D with dirichlet boundary conditions (d2u/dx2 = -f(x)), using the
FEM method using a random mesh on [0,1].
The mesh is generated by using a gaussian distribution to create random points in the interval [0,1], 
but we do this using the mean as the coordinate of each point in a regular mesh and a standard deviation
that is a parameter of the function.
The code uses the scipy library to solve the linear system of equations that arises from the FEM method.
The code also uses the matplotlib library to plot the solution."""


import numpy as np
import matplotlib.pyplot as plt
import scipy as sp
from scipy.integrate import fixed_quad

def generate_random_mesh(n, std_dev):
    """
    Generate a random mesh in the interval [0,1] using a Gaussian distribution.
    
    Parameters:
    n (int): Number of elements in the mesh.
    std_dev (float): Standard deviation of the Gaussian distribution.
    
    Returns:
    np.ndarray: Array of mesh points.
    """
    # Generate n+1 points in the interval [0,1]
    regular_points = np.linspace(0, 1, n + 1)
    
    # Generate random perturbations using Gaussian distribution
    perturbations = np.random.normal(0, std_dev, n + 1)
    
    # Create random mesh points and ensure they are within [0,1]
    random_mesh = np.clip(regular_points + perturbations, 0, 1)

    # Ensure the first and last points are exactly 0 and 1
    random_mesh[0] = 0.0
    random_mesh[-1] = 1.0

    # Ensure the mesh points are inside the interval [0,1]
    random_mesh = np.clip(random_mesh, 0, 1)
    
    # Sort the mesh points to ensure they are in increasing order
    random_mesh = np.sort(random_mesh)
    
    return random_mesh


def plot_mesh(mesh):
    """
    Plot the generated mesh.
    
    Parameters:
    mesh (np.ndarray): Array of mesh points.
    """
    plt.figure(figsize=(10, 1))
    plt.plot(mesh, np.zeros_like(mesh), 'o')
    plt.yticks([])
    plt.title('Generated Random Mesh')
    plt.xlabel('x')
    plt.grid()
    plt.show()


def global_stiffness_matrix(mesh):
    """Build the global stiffness matrix directly from the weak form: K_ij = <phi_i', phi_j'>, using analytical
    expressions worked out by hand"""
    n = len(mesh)
    K = np.zeros((n, n))
    h = np.diff(mesh)

    # internal nodes
    for i in range(1, n - 1):
        K[i, i - 1] = -1.0 / h[i - 1]
        K[i, i] = 1.0 / h[i - 1] + 1.0 / h[i]
        K[i, i + 1] = -1.0 / h[i]

    # Dirichlet BCs (u(0)=u(1)=0): first and last rows zero, diagonal ones
    K[0, 0] = 1.0
    K[-1, -1] = 1.0
    return K


def gaussian_quadrature(mesh, f, nq=3):
    """
    Compute the load vector b using from the definition: b_i = <f, phi_i>, Gaussian quadrature on each element.
    """
    n = len(mesh)
    b = np.zeros(n)
    for i in range(n - 1):
        x_l, x_r = mesh[i], mesh[i + 1]
        h = x_r - x_l

        # local basis functions
        def phi_l(x): return (x_r - x) / h
        def phi_r(x): return (x - x_l) / h

        # integrate contributions to b_i and b_{i+1}
        I_l, _ = fixed_quad(lambda x: f(x) * phi_l(x), x_l, x_r, n=nq)
        I_r, _ = fixed_quad(lambda x: f(x) * phi_r(x), x_l, x_r, n=nq)

        b[i] += I_l
        b[i + 1] += I_r

    # Apply Dirichlet BCs (zero at boundaries)
    b[0] = 0.0
    b[-1] = 0.0
    return b


def solve_vector_equation(K, b):
    """
    Solve the vector equation K*u = b for u.
    """
    u = np.linalg.solve(K, b)
    return u


# Main
def solve():
    n = 10
    std_dev = 0.05
    mesh = generate_random_mesh(n, std_dev)

    def f(x):
        return 4 * x - 6

    K = global_stiffness_matrix(mesh)
    b = gaussian_quadrature(mesh, f)
    u = solve_vector_equation(K, b)

   # Plot
    plt.figure()
    plt.plot(mesh, u, '-o', label='FEM solution')

    # exact solution with u(0)=u(1)=0
    x = np.linspace(0, 1, 400)
    u_exact = -(2 / 3) * x**3 + 3 * x**2 - (7 / 3) * x
    plt.plot(x, u_exact, '--', label='Exact solution')
    plt.xlabel('x')
    plt.ylabel('u(x)')
    plt.title('FEM Solution of Poisson Equation')
    plt.legend()
    plt.grid()
    plt.savefig("poisson_1D.png")
    plt.show()

    # Plotting f(x)
    f_points = f(x)
    plt.plot(x, f_points, label='f(x) = 4x - 6')
    plt.xlabel('x')
    plt.ylabel('f(x)')
    plt.title('Load function')
    plt.legend()
    plt.grid()
    plt.savefig("load_function.png")
    plt.show()

    return mesh, u, K, b


solve()
